<!--Golang-->
<!--Go语言基础-->
<!--1-->
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>数组和slice</title>
	<link rel="stylesheet" href="views/static/CSS/notes.css">
</head>
<body>
	<h1>数组类型和slice类型</h1>
	<p>go语言中提供了两种聚合类型，数组和结构体。slice和map是引用类型，但是由于数组和slice的联系过于密切，所以还是把数组和slice放在一起</p>
	<h2>数组类型</h2>
	<p>数组是具有固定长度，且拥有零个或多个相同数据类型元素的序列。</p>
	<p>数组在定义时就必须确定大小和类型，使用的时候只能改变其内容而不能改变其值。</p>
	<p>数组的长度是数组类型的一部分，所以说[3]int和[4]int是两种不同的类型</p>
	<h3>数组的定义</h3>
	<p>固定格式：<br/>
	var 变量名 [数组长度]数组类型</p>
	<h3>数组的初始化</h3>
	<p>标准格式：var 变量名 [数组长度]数组类型=[数组长度]数组类型{数组值列表}</p>
	<p>短变量声明：变量名 := [数组长度]数组类型{数组值列表}</p>
	<p>如果数组的长度为...的话，那么数组的长度由数组值列表的数量来推断</p>
	<p>指定某一个位置的元素的值，用键值对的方式，比如：<br/>
	arr := [5]int{0:2,4:3}<br/>
	就把0号元素指定成2,把4号元素指定成3了
	</p>
	<h3>多维数组</h3>
	<p>go语言支持多维数组，基本和cpp一样，本质就是数组的元素又是数组</p>
	<p><strong>
	tips：数组是值类型，并且在传递进函数的时候，不像其他语言会隐式地进行引用传递，而是会继续使用值传递。也就是复制一个副本作为形参。如果想要传递引用（数组庞大或想要修改原数组的值），要显示地指明数组的引用传递
	</strong></p>
	<p>想要得到数组的长度可以使用全局函数len(),访问数组的元素用下标运算符[]</p>
	<p>下面是一个数组的示例小程序：<br/>
<pre class="codepre">
package main

import (
        "fmt"
)

func double(arr [3]int) { //值传递的方式，要注意如果是[4]int类型就不能使用这个函数了
        for _, a := range arr { //这里用一下for range，会返回两个值，索引和值
                a *= 2
        }
}
func double2(arr *[3]int) { //引用传递的方式
        for i := 0; i &lt len(arr); i++ {
                arr[i] *= 2
        }
}

func main() {
        var arr1 [3]int                           //数组的标准声明
        var arr2 [3]int = [3]int{1, 2, 3}         //数组的标准初始化
        arr3 := [3]int{1, 2, 3}                   //数组的短变量声明
        arr4 := [...]int{1, 2, 3, 4}              //...的用法
        arr5 := [...]int{3: 100}                  //指定特定的元素
        arr6 := [3][2]int{{1, 2}, {2, 4}, {4, 6}} //多维数组
        fmt.Println(arr1, arr2, arr3, arr4, arr5, arr6)
        //演示值传递及引用传递的过程
        arr7 := [3]int{1, 2, 3}
        double(arr7)
        fmt.Println(arr7)
        double2(&amparr7)
        fmt.Println(arr7)
}

运行结果为：
[0 0 0] [1 2 3] [1 2 3] [1 2 3 4] [0 0 0 100] [[1 2] [2 4] [4 6]]
[1 2 3]
[2 4 6]
</pre>
	</p>
	<h2>slice(切片类型)</h2>
	<p>slice表示一个拥有相同类型元素的可变长序列。它是基于数组类型的一层封装，可以用来访问数组的部分或全部元素。支持自动扩容。</p>
	<p><strong>slice是一个引用类型</strong>就比如说：</p>
	<p>
<pre class="codepre">
s := [3]int{1, 2, 3}
a := s[0:2]
b := a[0:1]
b[0] = 100
fmt.Println(s, a, b)

输出为：
[100 2 3] [100 2] [100]
</pre>
	</p>
	<p>可以看到我修改了数组的切片的切片，但是数组和数组的切片的值都改变了，这证明了切片是一个引用类型。并且为修改数组提供了方法</p>
	<p>slice有三个属性：指针、长度和容量。<br/>
	指针指向数组的第一个可以从slice中访问元素，这个元素不一定是数组的第一个元素。<br/>
	长度是指slice中的元素个数，可以通过全局函数len()来访问<br/>
	容量是指底层数组的元素个数，可以通过全局函数cap()来访问</p>
	<h3>切片的定义</h3>
	<p>slice通常写成[]T，其中的元素类型都是T，看起来就像是一个没有长度的数组</p>
	<p>可以把切片想象成一个框，框住了一块连续的内存，属于引用类型，真正的数据都储存在底层的数组中</p>
	<h3>切片的初始化</h3>
	<p>切片通常是根据数组创建出来的，通过操作符s[i:j](其中0&lt=i&lt=j&lt=cap(s))创建一个新的的切片，区间是半开的(前闭后开)。这里的s可以是数组，可以是数组的指针，也可以是切片。值得一提的是，对字符串也有类似的操作s[i:j]，底层的原理与slice是一样的，只不过创建的叫子字符串，不叫切片</p>
	<p>可以直接定义一个切片: var s[]int{1,2,3,4}<br/>
这里其实是先创建了个匿名数组，然后又把其完整的切片赋值给了s</p>
	<p>如果slice的引用范围超过了被引对象的容量，即cap(s)，会导致程序宕机。但是如果超过了被引用对象的长度，即len(s)。就比如说：</p>
	<p>
<pre class="codepre">
s := [5]int{1, 2, 3, 4, 5}
a := s[0:2]	//a的len为2,由于底层的数组长度为5,所以cap为5
b := a[0:4]	//b的范围超过了len，但没有超过cap，所以是合法的
fmt.Println(a, b)

输出结果为：
[1 2] [1 2 3 4]
</pre>
	</p>
	<p>切片之间是不能直接比较的(数组可以)，所以不能直接用==来判断两个切片的元素是否相等，唯一能直接比较的nil。这里要注意，如果一个切片还没有被分配内存，其值才会是nil。而len=cap=0的切片不一定是nil，cap为0的切片可能已经被分配内存了(空数组)。</p>
	<p>内置函数make可以创建一个具有指定元素类型，长度和容量的slice。其中容量参数可以省略(容量和长度默认相等)</p>
	<p>
	make([]T,len,cap)
	make([]T,len)
	</p>
	<p>创建过程其实是make创建了一个匿名数组并返回了它的一个slice。这个数组只能通过这个slice来访问，数组的大小为cap，但slice只引用了len个</p>
	<h3>append函数</h3>
	<p>内置的append函数用来将元素追加到slice后面</p>
	<p>append函数的底层有一点像c++中vector的底层，如果说append后没有超过slice的cap，那么就会直接扩容。如果超过了的话，就会开辟一个更大的数组，并把原数组的元素都挪到新数组里面去，然后再扩展。如果发生了这种情况，那原来的slice指向的底层数组没有，slice就会失效。所以一般用原先的切片来接收append的返回值。s1=append(s1,2)。例如：</p>
	<p>
<pre class="codepre">
s := make([]int, 0, 2)
fmt.Println(len(s), cap(s), s)
s = append(s, 1)
fmt.Println(len(s), cap(s), s)
s = append(s, 2)
fmt.Println(len(s), cap(s), s)
s = append(s, 3)
fmt.Println(len(s), cap(s), s)
s = append(s, 4)
fmt.Println(len(s), cap(s), s)
s = append(s, 5)
fmt.Println(len(s), cap(s), s)
s = append(s, 6)
fmt.Println(len(s), cap(s), s)
s = append(s, 7)
fmt.Println(len(s), cap(s), s)

运行结果为:
0 2 []
1 2 [1]
2 2 [1 2]
3 4 [1 2 3]
4 4 [1 2 3 4]
5 8 [1 2 3 4 5]
6 8 [1 2 3 4 5 6]
7 8 [1 2 3 4 5 6 7]
</pre>
	</p>
	<p>可以清晰的看到append的扩容策略。具体扩容多少是比较复杂的，可以认为没有超过1024字节时是两倍两倍地扩容，超过了以后扩容会放缓</p>
	<p>有一种特殊写法可以将一个切片追加到另一个切片后面：<br/>
	s2=append(s2,s1...)<br/>
	...表示拆分，还有别的用途，后面再具体说</p>
	<h3>copy函数</h3>
	<p>copy函数可以将切片迅速地拷贝</p>
	<p>注意copy是按照目的切片的len来决定拷贝多少个的，超出的部分会被舍弃，并且copy是会直接对底层的数据进行的修改的，copy的目的切片大小最好大于等于源切片大小，小于的话也不会报错，会只拷贝一部分，并且copy是有返回值的，表示具体拷贝了多少个切片元素</p>
	<p>以下通过两个例子来示例，如果是两个底层数组不一样的话：
<pre class="codepre">
s1 := make([]int, 3, 6)
s := [7]int{1, 2, 3, 4, 5, 6, 7}
s2 := s[:]
fmt.Println(len(s1), cap(s1))
fmt.Println(len(s2), cap(s2))
fmt.Println(copy(s1, s2))	//输出实际拷贝的元素个数
fmt.Println(len(s1), cap(s1)) //拷贝是按照原来的切片的len来的，超出的部分会被舍弃
fmt.Println(len(s2), cap(s2))
fmt.Println(s1, s2)
s1[0] = 1000
fmt.Println(s1, s2) //拷贝是复制的关系，不是引用。

运行结果为：
3 6
7 7
3
3 6
7 7
[1 2 3] [1 2 3 4 5 6 7]
[1000 2 3] [1 2 3 4 5 6 7]
</pre>
	</p>
	<p>可以看到拷贝之后，目的切片的len和cap没有发生变化，并且拷贝的个数是按照目的切片的len来的</p>
	<p>如果是两个底层数组一样的情况：</p>
	<p>
<pre class="codepre">
s := [7]int{1, 2, 3, 4, 5, 6, 7}
a := s[0:4]
b := a[1:4]
fmt.Println(a, b)
fmt.Println(copy(a, b))
fmt.Println(a, b) //这里会发生神奇的事情，a和b都变了，为什么拷贝到a会让b也发生变化呢？再看看底层的数组
fmt.Println(s)    //是因为copy会直接改动底层数组，由于b引用了底层数组，所以也会发生变化

运行结果为：
[1 2 3 4] [2 3 4]
3
[2 3 4 4] [3 4 4]
[2 3 4 4 5 6 7]
</pre>
	</p>
	<h3>删除slice的元素</h3>
	<p>go语言没有提供删除切片某个位置元素的方法，但是可以利用copy或者append来删除某个元素</p>
	<p>a=append(a[:2],a[3:]...)这样就利用append删除了2号元素</p>
	<p>copy(a[:2],a[3:])<br/>
	a=a[:len(a)-1]<br/>
	这样就利用了copy删除了2号元素</p>
</body>
</html>
