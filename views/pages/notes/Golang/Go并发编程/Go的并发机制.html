<!-->Golang<-->
<!-->Go并发编程<-->
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Go的并发机制</title>
</head>
<body>
	<h1>Go的并发机制(原理)</h1>
	<p>先看一下官方给出的标语：不要用共享内存的方式来通信。作为替代，应该用通信作为手段来共享内存。</p>
	<h2>两级线程模型</h2>
	<p>线程实现的模型其实有三种：</p>
	<ol>
		<li>用户级线程模型</li>
		<li>内核级线程模型</li>
		<li>两极线程模型</li>
	</ol>
	<h3>用户级线程模型</h3>
	<p>此模型下的线程是由用户级别的线程库全权管理的，与内核完全无关。进行线程的创建，终止，切换和同步等操作时也不需要让CPU切换为内核态。所以用户级线程其实并不是真正的多线程，无法实现并发。实际上是多个线程对应一个KSE(内核调度实体)，其实还是属于一个进程的。所以也叫多对一(M:1)的线程实现。也有优点，由于不需要切换用户态内核态，所以速度会快很多，可移植性也要强很多</p>
	<h3>内核级线程模型</h3>
	<p>该模型的下的线程是由内核负责管理的。应用程序对线程的创建，终止，切换和同步都必须通过内核来完成，需要CPU切换到内核态。这种是完全意义上的多线程，能够完全地实现并发。进程中的每一个线程都对应一个KSE。所以也叫一对一(1:1)线程的实现。缺点就是慢，且限制多</p>
	<h3>两级线程模型</h3>
	<p>其实就是综合了前面两种线程的优点。一个进程可以对应多个KSE。也被叫做多对多(M:N)的线程实现。Goroutine就是一种两级线程模型</p>
	<h2>Goroutine线程实现模型</h2>
	<p>Goroutine线程实现模型中有三个重要的核心元素，M、P、G</p>
	<p>M：machine。一个M代表一个内核线程，或称为工作线程。由操作系统管理</p>
	<p>P：processor（处理器）。一个P代表执行一个Go代码片段所必须的资源(或称为上下文环境)。它负责衔接M和G的调度上下文，将等待执行的G与M对接</p>
	<p>G：goroutine(Go例程)。一个G代表一个Go代码片段。其实是一种轻量级的线程。包括了调用栈。重要的调度信息(比如channel等)</p>
	<p>下面用一张图来说明MPG的关系</p>
	<img src="static/img/Goroutine模型.png" alt="">
	<p>可以看到一个M与一个KSE总是一一对应。在Go的运行时系统中，使用M代表了一个内核调度实体。他们之间的关系用实线表示，代表这是一种非常稳固的关系，在M的生命周期内，只会与一个KSE产生关联</p>
	<p>M和P其实也总是一一对应的关系，但是在运行时某个P可能会和不同的M产生关联。如果M和P产生了关联，那么就形成了一个有效的G的运行环境(内核环境+上下文环境)。</p>
	<p>一个P会与多个G产生关联，其实这多个G会形成一个队列。与P关联的M会运行白色的G，而灰色的G代表正在排队的可运行程序。</p>
	<p>所以M-P-G(内核环境-上下文-代码段)就可以执行一段程序了</p>
	<h2>MPG的实现细节</h2>
	<h3>M</h3>
	<p>一个M代表一个内核线程。创建一个M有三种原因：</p>
	<ul>
		<li>没有足够的M来关联P并运行其中可运行的G</li>
		<li>运行时系统执行系统监控</li>
		<li>运行时系统执行垃圾回收</li>
	</ul>
	<p>来看一下简化的m的结构</p>
	<pre class="definepre">
type m struct{
	gO *g	//一个特殊的goroutine。是在Go运行时系统在启动之初创建的，用于执行一些运行时任务
	mstartfn func()	//在新的M上启动某个特殊任务的函数(系统监控，GC辅助，M自旋)
	curg *g	//当前M正在运行的那个G的指针
	p puintptr //指向与当前M相关联的那个P
	nextp puintptr	//用于暂存与当前M有潜在关联的P。调度器将某个P赋予某个M的nextp字段的操作称为预连
	spinning bool	//表示这个M是否正在寻找可运行的G。在寻找的过程中M会处于自旋状态
	lockdeg *g	//通常一个M可以运行多个G，但可以让M和G锁定，这个M只能运行这个G，这个G也只能由这个M运行
}
	</pre>
	<img src="static/img/M.png" alt="">
	<p>mstartfn+curg+p最能体现当前M的即时情况。一个M在被创建之初会被加入全局的M列表(runtime.allm)。起始函数gO(如果需要的话，比如执行系统监控和垃圾回收)和预联的P nextp被设置。最后，运行时系统会为这个M专门创建一个新的内核线程并与之关联。如此以来这个M就为运行G做好了准备</p>
	<p>新的M被创建后，运行时系统会对其执行一系列的初始化工作，包括对自身所持栈空间和信号处理方面的初始化。然后如果有初始函数就执行初始函数，如果没有的话就与预联的P关联，并准备执行其他任务。</p>
	<p>通常最多会有10000个M</p>
	<h3>P</h3>
	<pre class="definepre">
type p struct{
	runq //可运行G队列
	gfree //自由G列表
	stat //状态
}
	</pre>
	<p>P是G能够在M中运行的关键。Go的运行时系统会适时地让P与不同的M建立或断开关联，以使P中的那些可运行的G能够及时获得运行时机，这与操作系统内核在CPU上实时的切换不同的进程或线程的情形类似</p>
	<p>P的最大数量通常被设置成当前计算机的最大核心数。P的最大数量实际上是对程序中并发运行的G的规模的一种限制。P的数量即为可运行的G的队列的数量。一个G在被启动后，会先被追加到某个P的可运行G队列中。以等待运行时机。所以基本上P就是一个任务分发员，每个P手上都有一堆任务(G)，他可以把手上的任务分发给M，让M执行。发完的任务传单也别扔了，信息改改下次还能用(自由G列表)。所以Go语言想启动一个G的时候会先从相应P的自由G列表中获取一个现成的G</p>
	<img src="static/img/P.png" alt="">
	<p>这里看似一个P与一个M对应就行了。那么为什么P只有几个，而M有10000个。这是因为当M因为系统调用而阻塞，运行时系统会把该M和与之关联的P分离开来。这时，如果这个P的可运行G队列中还有没有被运行的G，那么运行时系统就会找到一个空闲M或新建一个M，并与该P关联以满足这些G的运行需要</p>
	<p>P也有一个全局P列表和一个空闲P列表。</p>
	<p>p是有状态的，其主要状态如下：</p>
	<ul>
		<li>Pidle:当前P并未与任何M存在关联</li>
		<li>Prunning:当前P正在与某个M关联</li>
		<li>Psyscall:当前P中的运行的那个G正在进行系统调用</li>
		<li>Pgcstop:表面运行时系统需要停止调度。比如进行垃圾回收时</li>
		<li>Pdead:表明当前P已经不会再被使用了</li>
		<li></li>
	</ul>
	<h3>G</h3>
	<p>一个G就代表一个goroutine。运行时系统收到一个调用后，会先在本地P的自由G列表和调度器的自由G列表获取可用的G，如果没有，就新创建一个G。新建一个G后，会把这个G放入全局G列表中。然后对其进行初始化，包括关联go函数以及设置该G的状态和ID等步骤。在初始化完成后，这个G会被储存到本地P的runnext字段中。该字段用于储存新鲜出炉的G，以求更早地运行他，如果runnext字段已经有了一个G，那么就会被踢到P的可运行G队列的末尾。如果还满了，就会被踢到调度器的可运行G队列</p>
	<p>G有状态：</p>
	<ol>
		<li>Gidel:表示G刚被创建，还没有进行初始化</li>
		<li>Grunable:表示G正在可运行队列中等待</li>
		<li>Grunning:表示正在运行</li>
		<li>Gsyscall:表示G正在执行某个系统调用</li>
		<li>Gwaiting:表示G正在阻塞</li>
		<li>Gdead:表示G正在闲置</li>
		<li>Gcopystack:表示当前G的栈正在被移动，移动的原因可能是栈的扩展或收缩</li>
	</ol>
	<h3>核心元素的容器</h3>
	<p>总结一下承载MPG的容器</p>
	<table>
		<thead>
		<tr>
			<td>中文名称</td>
			<td>源码中的名称</td>
			<td>作用域</td>
			<td>说明</td>
		</tr>
		</thead>
		<tr>
			<td>全局M列表</td>
			<td>runtime.allm</td>
			<td>运行时系统</td>
			<td>存放所有M的单向链表</td>
		</tr>
		<tr>
			<td>全局P列表</td>
			<td>runtime.allp</td>
			<td>运行时系统</td>
			<td>存放所有P的一个数组</td>
		</tr>
		<tr>
			<td>全局G列表</td>
			<td>runtime.allgs</td>
			<td>运行时系统</td>
			<td>存放所有G的一个切片</td>
		</tr>
		<tr>
			<td>调度器的空闲M列表</td>
			<td>runtime.sched.midle</td>
			<td>调度器</td>
			<td>存放空闲的M的单向链表</td>
		</tr>
		<tr>
			<td>调度器的空闲P列表</td>
			<td>runtime.sched.pidle</td>
			<td>调度器</td>
			<td>存放空闲的P的单向链表</td>
		</tr>
		<tr>
			<td>调度器的可运行G列表</td>
			<td>runtime.sched.runqhead/runtime.sched.runqtail</td>
			<td>存放可运行的G的一个队列(有头尾两个指针，遵循FIFO先入先出)</td>
			<td></td>
		</tr>
		<tr>
			<td>调度器的自由G列表</td>
			<td>runtime.sched.gfreeStack/runtime.sched.gfreeNoStack</td>
			<td>调度器</td>
			<td>存放可运行的G的两个单向链表，FILO</td>
		</tr>
		<tr>
			<td>P的可运行G列表</td>
			<td>runtime.p.runq</td>
			<td>本地P</td>
			<td>存放当前P中的可运行G的一个队列</td>
		</tr>
		<tr>
			<td>P的自由列表</td>
			<td>runtime.p.gfree</td>
			<td>本地P</td>
			<td>存放当前P中的自由G的一个单向链表</td>
		</tr>

	</table>
	<p>这里要说一下两个可运行G列表，他们同等的运行机会。从Gsyscall状态转出的G都会被放入调度器的可运行G队列。而从系统初始化的G都会被放入本地P的可运行G队列。至于从Gwaiting状态转出的G，都有可能去，而且可能会被直接运行。</p>
</body>
</html>
